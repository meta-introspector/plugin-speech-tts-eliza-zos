{"version":3,"sources":["../src/services/speech.ts","../src/services/audioUtils.ts","../src/services/transcription.ts","../src/index.ts"],"sourcesContent":["import { PassThrough } from \"stream\";\nimport { Readable } from \"node:stream\";\nimport { ReadableStream } from \"node:stream/web\";\nimport { IAgentRuntime, ISpeechService, ServiceType } from \"@elizaos/core\";\nimport { getWavHeader } from \"./audioUtils.js\";\nimport { Service } from \"@elizaos/core\";\nimport { validateNodeConfig } from \"../environment.js\";\nimport * as Echogarden from \"echogarden\";\nimport { elizaLogger } from \"@elizaos/core\";\n\nfunction prependWavHeader(\n    readable: Readable,\n    audioLength: number,\n    sampleRate: number,\n    channelCount: number = 1,\n    bitsPerSample: number = 16\n): Readable {\n    const wavHeader = getWavHeader(\n        audioLength,\n        sampleRate,\n        channelCount,\n        bitsPerSample\n    );\n    let pushedHeader = false;\n    const passThrough = new PassThrough();\n    readable.on(\"data\", function (data) {\n        if (!pushedHeader) {\n            passThrough.push(wavHeader);\n            pushedHeader = true;\n        }\n        passThrough.push(data);\n    });\n    readable.on(\"end\", function () {\n        passThrough.end();\n    });\n    return passThrough;\n}\n\nasync function getVoiceSettings(runtime: IAgentRuntime) {\n    const hasElevenLabs = !!runtime.getSetting(\"ELEVENLABS_XI_API_KEY\");\n    const useVits = !hasElevenLabs;\n\n    // Get voice settings from character card\n    const vitsSettings = runtime.character.settings?.voice\n    const elevenlabsSettings = runtime.character.settings?.voice?.elevenlabs;\n\n    elizaLogger.log(\"Voice settings:\", {\n        hasElevenLabs,\n        useVits,\n        vitsSettings,\n        elevenlabsSettings,\n    });\n\n    return {\n        elevenlabsVoiceId:\n            elevenlabsSettings?.voiceId ||\n            runtime.getSetting(\"ELEVENLABS_VOICE_ID\") || \n            \"21m00Tcm4TlvDq8ikWAM\",\n        elevenlabsModel:\n            elevenlabsSettings?.model ||\n            runtime.getSetting(\"ELEVENLABS_MODEL_ID\") ||\n            \"eleven_multilingual_v2\",\n        elevenlabsStability:\n            elevenlabsSettings?.stability ||\n            runtime.getSetting(\"ELEVENLABS_VOICE_STABILITY\") ||\n            \"0.5\",\n        elevenlabsStreamingLatency:\n            runtime.getSetting(\"ELEVENLABS_OPTIMIZE_STREAMING_LATENCY\") ||\n            \"4\",\n        elevenlabsOutputFormat:\n            runtime.getSetting(\"ELEVENLABS_OUTPUT_FORMAT\") || \"pcm_16000\",\n        elevenlabsSimilarity: runtime.getSetting(\"ELEVENLABS_VOICE_SIMILARITY_BOOST\") || \"0.9\",\n        elevenlabsStyle: runtime.getSetting(\"ELEVENLABS_VOICE_STYLE\") || \"0.66\",\n        elevenlabsSpeakerBoost: runtime.getSetting(\"ELEVENLABS_VOICE_USE_SPEAKER_BOOST\") || \"false\",\n        vitsVoice:\n            vitsSettings?.model ||\n            vitsSettings?.url ||\n            runtime.getSetting(\"VITS_VOICE\") ||\n            \"en_US-hfc_female-medium\",\n        elevenlabsUrl: runtime.getSetting(\"ELEVENLABS_XI_API_URL\") || \"https://api.elevenlabs.io/v1\",\n        useVits,\n    };\n}\n\nasync function textToSpeech(runtime: IAgentRuntime, text: string) {\n    // await validateNodeConfig(runtime);\n    const { \n        elevenlabsVoiceId,\n        elevenlabsModel,\n        elevenlabsUrl, \n        elevenlabsStreamingLatency, \n        elevenlabsOutputFormat,\n        elevenlabsSimilarity,\n        elevenlabsStability,\n        elevenlabsStyle,\n        elevenlabsSpeakerBoost,\n    } = await getVoiceSettings(runtime);\n\n    try {\n        elizaLogger.log(\"sending request to Eleven Labs API\");\n        elizaLogger.log(\"Eleven Labs voice ID:\", elevenlabsVoiceId);\n        elizaLogger.log(\"Eleven Labs model ID:\", elevenlabsModel);\n        elizaLogger.log(\"Eleven Labs streaming latency:\", elevenlabsStreamingLatency);\n        elizaLogger.log(\"Eleven Labs output format:\", elevenlabsOutputFormat);\n        elizaLogger.log(\"Eleven Labs similarity boost:\", elevenlabsSimilarity);\n        elizaLogger.log(\"Eleven Labs stability:\", elevenlabsStability);\n        elizaLogger.log(\"Eleven Labs style:\", elevenlabsStyle);\n        elizaLogger.log(\"Eleven Labs speaker boost:\", elevenlabsSpeakerBoost);\n\n        const response = await fetch(\n            `${elevenlabsUrl}/text-to-speech/${elevenlabsVoiceId}/stream?optimize_streaming_latency=${elevenlabsStreamingLatency}&output_format=${elevenlabsOutputFormat}`,\n            {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"xi-api-key\": runtime.getSetting(\"ELEVENLABS_XI_API_KEY\"),\n                },\n                body: JSON.stringify({\n                    model_id: elevenlabsModel,\n                    text: text,\n                    voice_settings: {\n                        similarity_boost: elevenlabsSimilarity,\n                        stability: elevenlabsStability,\n                        style: elevenlabsStyle,\n                        use_speaker_boost: elevenlabsSpeakerBoost,\n                    },\n                }),\n            }\n        );\n\n        const status = response.status;\n        if (status != 200) {\n            const errorBodyString = await response.text();\n            const errorBody = JSON.parse(errorBodyString);\n\n            // Check for quota exceeded error\n            if (\n                status === 401 &&\n                errorBody.detail?.status === \"quota_exceeded\"\n            ) {\n                elizaLogger.log(\n                    \"ElevenLabs quota exceeded, falling back to VITS\"\n                );\n                throw new Error(\"QUOTA_EXCEEDED\");\n            }\n\n            throw new Error(\n                `Received status ${status} from Eleven Labs API: ${errorBodyString}`\n            );\n        }\n\n        if (response) {\n            const webStream = ReadableStream.from(\n                response.body as ReadableStream\n            );\n            const reader = webStream.getReader();\n\n            const readable = new Readable({\n                read() {\n                    reader.read().then(({ done, value }) => {\n                        if (done) {\n                            this.push(null);\n                        } else {\n                            this.push(value);\n                        }\n                    });\n                },\n            });\n\n            if (\n                elevenlabsOutputFormat.startsWith(\"pcm_\")\n            ) {\n                const sampleRate = parseInt(\n                    elevenlabsOutputFormat.substring(4)\n                );\n                const withHeader = prependWavHeader(\n                    readable,\n                    1024 * 1024 * 100,\n                    sampleRate,\n                    1,\n                    16\n                );\n                return withHeader;\n            } else {\n                return readable;\n            }\n        } else {\n            return new Readable({\n                read() {},\n            });\n        }\n    } catch (error) {\n        if (error.message === \"QUOTA_EXCEEDED\") {\n            // Fall back to VITS\n            const { vitsVoice } = await getVoiceSettings(runtime);\n            const { audio } = await Echogarden.synthesize(text, {\n                engine: \"vits\",\n                voice: vitsVoice,\n            });\n\n            let wavStream: Readable;\n            if (audio instanceof Buffer) {\n                elizaLogger.log(\"audio is a buffer\");\n                wavStream = Readable.from(audio);\n            } else if (\"audioChannels\" in audio && \"sampleRate\" in audio) {\n                elizaLogger.log(\"audio is a RawAudio\");\n                const floatBuffer = Buffer.from(audio.audioChannels[0].buffer);\n                elizaLogger.log(\"buffer length: \", floatBuffer.length);\n\n                // Get the sample rate from the RawAudio object\n                const sampleRate = audio.sampleRate;\n\n                // Create a Float32Array view of the floatBuffer\n                const floatArray = new Float32Array(floatBuffer.buffer);\n\n                // Convert 32-bit float audio to 16-bit PCM\n                const pcmBuffer = new Int16Array(floatArray.length);\n                for (let i = 0; i < floatArray.length; i++) {\n                    pcmBuffer[i] = Math.round(floatArray[i] * 32767);\n                }\n\n                // Prepend WAV header to the buffer\n                const wavHeaderBuffer = getWavHeader(\n                    pcmBuffer.length * 2,\n                    sampleRate,\n                    1,\n                    16\n                );\n                const wavBuffer = Buffer.concat([\n                    wavHeaderBuffer,\n                    Buffer.from(pcmBuffer.buffer),\n                ]);\n\n                wavStream = Readable.from(wavBuffer);\n            } else {\n                throw new Error(\"Unsupported audio format\");\n            }\n            return wavStream;\n        }\n        throw error; // Re-throw other errors\n    }\n}\n\nasync function processVitsAudio(audio: any): Promise<Readable> {\n    let wavStream: Readable;\n    if (audio instanceof Buffer) {\n        elizaLogger.log(\"audio is a buffer\");\n        wavStream = Readable.from(audio);\n    } else if (\"audioChannels\" in audio && \"sampleRate\" in audio) {\n        elizaLogger.log(\"audio is a RawAudio\");\n        const floatBuffer = Buffer.from(audio.audioChannels[0].buffer);\n        elizaLogger.log(\"buffer length: \", floatBuffer.length);\n\n        const sampleRate = audio.sampleRate;\n        const floatArray = new Float32Array(floatBuffer.buffer);\n        const pcmBuffer = new Int16Array(floatArray.length);\n\n        for (let i = 0; i < floatArray.length; i++) {\n            pcmBuffer[i] = Math.round(floatArray[i] * 32767);\n        }\n\n        const wavHeaderBuffer = getWavHeader(\n            pcmBuffer.length * 2,\n            sampleRate,\n            1,\n            16\n        );\n        const wavBuffer = Buffer.concat([\n            wavHeaderBuffer,\n            Buffer.from(pcmBuffer.buffer),\n        ]);\n        wavStream = Readable.from(wavBuffer);\n    } else {\n        throw new Error(\"Unsupported audio format\");\n    }\n    return wavStream;\n}\n\nasync function generateVitsAudio(\n    runtime: IAgentRuntime,\n    text: string\n): Promise<Readable> {\n    const { vitsVoice } = await getVoiceSettings(runtime);\n    const { audio } = await Echogarden.synthesize(text, {\n        engine: \"vits\",\n        voice: vitsVoice,\n    });\n    return processVitsAudio(audio);\n}\n\nexport class SpeechService extends Service implements ISpeechService {\n    static serviceType: ServiceType = ServiceType.SPEECH_GENERATION;\n\n    async initialize(_runtime: IAgentRuntime): Promise<void> {}\n\n    getInstance(): ISpeechService {\n        return SpeechService.getInstance();\n    }\n\n    async generate(runtime: IAgentRuntime, text: string): Promise<Readable> {\n        try {\n            elizaLogger.log(\"Generating speech for text:\", text);\n            const { useVits } = await getVoiceSettings(runtime);\n\n            if (useVits || !runtime.getSetting(\"ELEVENLABS_XI_API_KEY\")) {\n                return await generateVitsAudio(runtime, text);\n            }\n\n            return await textToSpeech(runtime, text);\n        } catch (error) {\n            console.error(\"Speech generation error:\", error);\n            return await generateVitsAudio(runtime, text);\n        }\n    }\n}\n","export function getWavHeader(\n    audioLength: number,\n    sampleRate: number,\n    channelCount: number = 1,\n    bitsPerSample: number = 16\n): Buffer {\n    const wavHeader = Buffer.alloc(44);\n    wavHeader.write(\"RIFF\", 0);\n    wavHeader.writeUInt32LE(36 + audioLength, 4); // Length of entire file in bytes minus 8\n    wavHeader.write(\"WAVE\", 8);\n    wavHeader.write(\"fmt \", 12);\n    wavHeader.writeUInt32LE(16, 16); // Length of format data\n    wavHeader.writeUInt16LE(1, 20); // Type of format (1 is PCM)\n    wavHeader.writeUInt16LE(channelCount, 22); // Number of channels\n    wavHeader.writeUInt32LE(sampleRate, 24); // Sample rate\n    wavHeader.writeUInt32LE(\n        (sampleRate * bitsPerSample * channelCount) / 8,\n        28\n    ); // Byte rate\n    wavHeader.writeUInt16LE((bitsPerSample * channelCount) / 8, 32); // Block align ((BitsPerSample * Channels) / 8)\n    wavHeader.writeUInt16LE(bitsPerSample, 34); // Bits per sample\n    wavHeader.write(\"data\", 36); // Data chunk header\n    wavHeader.writeUInt32LE(audioLength, 40); // Data chunk size\n    return wavHeader;\n}\n","import {\n    elizaLogger,\n    IAgentRuntime,\n    ITranscriptionService,\n    settings,\n    TranscriptionProvider,\n} from \"@elizaos/core\";\nimport { Service, ServiceType } from \"@elizaos/core\";\nimport { exec } from \"child_process\";\nimport { File } from \"formdata-node\";\nimport fs from \"fs\";\nimport { nodewhisper } from \"nodejs-whisper\";\nimport OpenAI from \"openai\"; // todo, can probably move this to model provider or whateer\nimport os from \"os\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport { promisify } from \"util\";\nimport { createClient, DeepgramClient } from \"@deepgram/sdk\";\n\n// const __dirname = path.dirname(new URL(import.meta.url).pathname); #compatibility issues with windows\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconst execAsync = promisify(exec);\n\nexport class TranscriptionService\n    extends Service\n    implements ITranscriptionService\n{\n    private runtime: IAgentRuntime | null = null;\n    static serviceType: ServiceType = ServiceType.TRANSCRIPTION;\n    private CONTENT_CACHE_DIR: string;\n    private DEBUG_AUDIO_DIR: string;\n    private TARGET_SAMPLE_RATE = 16000; // Common sample rate for speech recognition\n    private isCudaAvailable: boolean = false;\n\n    /**\n     * CHANGED: We now use TranscriptionProvider instead of separate flags/strings.\n     * This allows us to handle character settings, env variables, and fallback logic.\n     */\n    private transcriptionProvider: TranscriptionProvider | null = null;\n\n    private deepgram: DeepgramClient | null = null;\n    private openai: OpenAI | null = null;\n\n    /**\n     * We keep the queue and processing logic as is.\n     */\n    private queue: { audioBuffer: ArrayBuffer; resolve: Function }[] = [];\n    private processing: boolean = false;\n\n    /**\n     * CHANGED: initialize() now checks:\n     * 1) character.settings.transcription (if available and keys exist),\n     * 2) then the .env TRANSCRIPTION_PROVIDER,\n     * 3) then old fallback logic (Deepgram -> OpenAI -> local).\n     */\n    async initialize(_runtime: IAgentRuntime): Promise<void> {\n        this.runtime = _runtime;\n\n        const openaiBaseURL = this.runtime.getSetting(\n            \"OPENAI_API_URL\"\n        )\n\n        elizaLogger.log(\"OPENAI_API_URL\", openaiBaseURL)\n\n        // 1) Check character settings\n        let chosenProvider: TranscriptionProvider | null = null;\n        const charSetting = this.runtime.character?.settings?.transcription;\n\n        if (charSetting === TranscriptionProvider.Deepgram) {\n            const deepgramKey = this.runtime.getSetting(\"DEEPGRAM_API_KEY\");\n            if (deepgramKey) {\n                this.deepgram = createClient(deepgramKey);\n                chosenProvider = TranscriptionProvider.Deepgram;\n            }\n        } else if (charSetting === TranscriptionProvider.OpenAI) {\n            const openaiKey = this.runtime.getSetting(\"OPENAI_API_KEY\");\n            if (openaiKey) {\n                this.openai = new OpenAI({ apiKey: openaiKey, baseURL: openaiBaseURL });\n                chosenProvider = TranscriptionProvider.OpenAI;\n            }\n        } else if (charSetting === TranscriptionProvider.Local) {\n            chosenProvider = TranscriptionProvider.Local;\n        }\n\n        // 2) If not chosen from character, check .env\n        if (!chosenProvider) {\n            const envProvider = this.runtime.getSetting(\n                \"TRANSCRIPTION_PROVIDER\"\n            );\n            if (envProvider) {\n                switch (envProvider.toLowerCase()) {\n                    case \"deepgram\":\n                        {\n                            const dgKey =\n                                this.runtime.getSetting(\"DEEPGRAM_API_KEY\");\n                            if (dgKey) {\n                                this.deepgram = createClient(dgKey);\n                                chosenProvider = TranscriptionProvider.Deepgram;\n                            }\n                        }\n                        break;\n                    case \"openai\":\n                        {\n                            const openaiKey =\n                                this.runtime.getSetting(\"OPENAI_API_KEY\");\n                            if (openaiKey) {\n                                this.openai = new OpenAI({ apiKey: openaiKey, baseURL: openaiBaseURL});\n                                chosenProvider = TranscriptionProvider.OpenAI;\n                            }\n                        }\n                        break;\n                    case \"local\":\n                        chosenProvider = TranscriptionProvider.Local;\n                        break;\n                }\n            }\n        }\n\n        // 3) If still none, fallback to old logic: Deepgram -> OpenAI -> local\n        if (!chosenProvider) {\n            const deepgramKey = this.runtime.getSetting(\"DEEPGRAM_API_KEY\");\n            if (deepgramKey) {\n                this.deepgram = createClient(deepgramKey);\n                chosenProvider = TranscriptionProvider.Deepgram;\n            } else {\n                const openaiKey = this.runtime.getSetting(\"OPENAI_API_KEY\");\n                if (openaiKey) {\n                    this.openai = new OpenAI({ apiKey: openaiKey, baseURL: openaiBaseURL });\n                    chosenProvider = TranscriptionProvider.OpenAI;\n                } else {\n                    chosenProvider = TranscriptionProvider.Local;\n                }\n            }\n        }\n\n        this.transcriptionProvider = chosenProvider;\n\n        // Leave detectCuda as is.\n        this.detectCuda();\n    }\n\n    constructor() {\n        super();\n        const rootDir = path.resolve(__dirname, \"../../\");\n        this.CONTENT_CACHE_DIR = path.join(rootDir, \"content_cache\");\n        this.DEBUG_AUDIO_DIR = path.join(rootDir, \"debug_audio\");\n        this.ensureCacheDirectoryExists();\n        this.ensureDebugDirectoryExists();\n        // TODO: It'd be nice to handle this more gracefully, but we can do local transcription for now\n        // TODO: remove the runtime from here, use it when called\n        // if (runtime.getSetting(\"OPENAI_API_KEY\")) {\n        //     this.openai = new OpenAI({\n        //         apiKey: runtime.getSetting(\"OPENAI_API_KEY\"),\n        //     });\n        // } else {\n        //     this.detectCuda();\n        // }\n    }\n\n    private ensureCacheDirectoryExists() {\n        if (!fs.existsSync(this.CONTENT_CACHE_DIR)) {\n            fs.mkdirSync(this.CONTENT_CACHE_DIR, { recursive: true });\n        }\n    }\n\n    private ensureDebugDirectoryExists() {\n        if (!fs.existsSync(this.DEBUG_AUDIO_DIR)) {\n            fs.mkdirSync(this.DEBUG_AUDIO_DIR, { recursive: true });\n        }\n    }\n\n    private detectCuda() {\n        const platform = os.platform();\n        if (platform === \"linux\") {\n            try {\n                fs.accessSync(\"/usr/local/cuda/bin/nvcc\", fs.constants.X_OK);\n                this.isCudaAvailable = true;\n                elizaLogger.log(\n                    \"CUDA detected. Transcription will use CUDA acceleration.\"\n                );\n                // eslint-disable-next-line\n            } catch (_error) {\n                elizaLogger.log(\n                    \"CUDA not detected. Transcription will run on CPU.\"\n                );\n            }\n        } else if (platform === \"win32\") {\n            const cudaPath = path.join(\n                settings.CUDA_PATH ||\n                    \"C:\\\\Program Files\\\\NVIDIA GPU Computing Toolkit\\\\CUDA\\\\v11.0\",\n                \"bin\",\n                \"nvcc.exe\"\n            );\n            if (fs.existsSync(cudaPath)) {\n                this.isCudaAvailable = true;\n                elizaLogger.log(\n                    \"CUDA detected. Transcription will use CUDA acceleration.\"\n                );\n            } else {\n                elizaLogger.log(\n                    \"CUDA not detected. Transcription will run on CPU.\"\n                );\n            }\n        } else {\n            elizaLogger.log(\n                \"CUDA not supported on this platform. Transcription will run on CPU.\"\n            );\n        }\n    }\n\n    private async convertAudio(inputBuffer: ArrayBuffer): Promise<Buffer> {\n        const inputPath = path.join(\n            this.CONTENT_CACHE_DIR,\n            `input_${Date.now()}.wav`\n        );\n        const outputPath = path.join(\n            this.CONTENT_CACHE_DIR,\n            `output_${Date.now()}.wav`\n        );\n\n        fs.writeFileSync(inputPath, Buffer.from(inputBuffer));\n\n        try {\n            const { stdout } = await execAsync(\n                `ffprobe -v error -show_entries stream=codec_name,sample_rate,channels -of json \"${inputPath}\"`\n            );\n            const probeResult = JSON.parse(stdout);\n            const stream = probeResult.streams[0];\n\n            elizaLogger.log(\"Input audio info:\", stream);\n\n            let ffmpegCommand = `ffmpeg -i \"${inputPath}\" -ar ${this.TARGET_SAMPLE_RATE} -ac 1`;\n\n            if (stream.codec_name === \"pcm_f32le\") {\n                ffmpegCommand += \" -acodec pcm_s16le\";\n            }\n\n            ffmpegCommand += ` \"${outputPath}\"`;\n\n            elizaLogger.log(\"FFmpeg command:\", ffmpegCommand);\n\n            await execAsync(ffmpegCommand);\n\n            const convertedBuffer = fs.readFileSync(outputPath);\n            fs.unlinkSync(inputPath);\n            fs.unlinkSync(outputPath);\n            return convertedBuffer;\n        } catch (error) {\n            elizaLogger.error(\"Error converting audio:\", error);\n            throw error;\n        }\n    }\n\n    private async saveDebugAudio(audioBuffer: ArrayBuffer, prefix: string) {\n        this.ensureDebugDirectoryExists();\n\n        const filename = `${prefix}_${Date.now()}.wav`;\n        const filePath = path.join(this.DEBUG_AUDIO_DIR, filename);\n\n        fs.writeFileSync(filePath, Buffer.from(audioBuffer));\n        elizaLogger.log(`Debug audio saved: ${filePath}`);\n    }\n\n    public async transcribeAttachment(\n        audioBuffer: ArrayBuffer\n    ): Promise<string | null> {\n        return await this.transcribe(audioBuffer);\n    }\n\n    /**\n     * If the audio buffer is too short, return null. Otherwise push to queue.\n     */\n    public async transcribe(audioBuffer: ArrayBuffer): Promise<string | null> {\n        // if the audio buffer is less than .2 seconds, just return null\n        if (audioBuffer.byteLength < 0.2 * 16000) {\n            return null;\n        }\n        return new Promise((resolve) => {\n            this.queue.push({ audioBuffer, resolve });\n            if (!this.processing) {\n                this.processQueue();\n            }\n        });\n    }\n\n    public async transcribeAttachmentLocally(\n        audioBuffer: ArrayBuffer\n    ): Promise<string | null> {\n        return this.transcribeLocally(audioBuffer);\n    }\n\n    /**\n     * CHANGED: processQueue() uses the final transcriptionProvider enum set in initialize().\n     */\n    private async processQueue(): Promise<void> {\n        // Exit if already processing or if the queue is empty\n        if (this.processing || this.queue.length === 0) return;\n        this.processing = true;\n\n        while (this.queue.length > 0) {\n            const { audioBuffer, resolve } = this.queue.shift()!;\n            let result: string | null = null;\n\n            switch (this.transcriptionProvider) {\n                case TranscriptionProvider.Deepgram:\n                    result = await this.transcribeWithDeepgram(audioBuffer);\n                    break;\n                case TranscriptionProvider.OpenAI:\n                    result = await this.transcribeWithOpenAI(audioBuffer);\n                    break;\n                default:\n                    result = await this.transcribeLocally(audioBuffer);\n            }\n\n            resolve(result);\n        }\n\n        this.processing = false;\n    }\n\n    /**\n     * Original logic from main is now handled by the final fallback in initialize().\n     * We'll keep transcribeUsingDefaultLogic() if needed by other code references,\n     * but it's no longer invoked in the new flow.\n     */\n    private async transcribeUsingDefaultLogic(\n        audioBuffer: ArrayBuffer\n    ): Promise<string | null> {\n        if (this.deepgram) {\n            return await this.transcribeWithDeepgram(audioBuffer);\n        } else if (this.openai) {\n            return await this.transcribeWithOpenAI(audioBuffer);\n        }\n        return await this.transcribeLocally(audioBuffer);\n    }\n\n    private async transcribeWithDeepgram(\n        audioBuffer: ArrayBuffer\n    ): Promise<string | null> {\n        const buffer = Buffer.from(audioBuffer);\n        const response = await this.deepgram.listen.prerecorded.transcribeFile(\n            buffer,\n            {\n                model: \"nova-3\",\n                language: \"en\",\n                smart_format: true,\n            }\n        );\n        const result =\n            response.result.results.channels[0].alternatives[0].transcript;\n        return result;\n    }\n\n    private async transcribeWithOpenAI(\n        audioBuffer: ArrayBuffer\n    ): Promise<string | null> {\n        elizaLogger.log(\"Transcribing audio with OpenAI...\");\n\n        try {\n            await this.saveDebugAudio(audioBuffer, \"openai_input_original\");\n\n            const arrayBuffer = new Uint8Array(audioBuffer).buffer;\n            const convertedBuffer = Buffer.from(await this.convertAudio(arrayBuffer)).buffer;\n\n            await this.saveDebugAudio(\n                convertedBuffer,\n                \"openai_input_converted\"\n            );\n\n            const file = new File([convertedBuffer], \"audio.wav\", {\n                type: \"audio/wav\",\n            });\n\n            const result = await this.openai!.audio.transcriptions.create({\n                model: \"whisper-1\",\n                language: \"en\",\n                response_format: \"text\",\n                file: file,\n            });\n\n            const trimmedResult = (result as any).trim();\n            elizaLogger.log(`OpenAI speech to text result: \"${trimmedResult}\"`);\n\n            return trimmedResult;\n        } catch (error) {\n            elizaLogger.error(\n                \"Error in OpenAI speech-to-text conversion:\",\n                error\n            );\n            if (error.response) {\n                elizaLogger.error(\"Response data:\", error.response.data);\n                elizaLogger.error(\"Response status:\", error.response.status);\n                elizaLogger.error(\"Response headers:\", error.response.headers);\n            } else if (error.request) {\n                elizaLogger.error(\"No response received:\", error.request);\n            } else {\n                elizaLogger.error(\"Error setting up request:\", error.message);\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Local transcription with nodejs-whisper. We keep it as it was,\n     * just making sure to handle CUDA if available.\n     */\n    public async transcribeLocally(\n        audioBuffer: ArrayBuffer\n    ): Promise<string | null> {\n        try {\n            elizaLogger.log(\"Transcribing audio locally...\");\n\n            await this.saveDebugAudio(audioBuffer, \"local_input_original\");\n\n            const arrayBuffer = new Uint8Array(audioBuffer).buffer;\n            const convertedBuffer = Buffer.from(await this.convertAudio(arrayBuffer)).buffer;\n\n            await this.saveDebugAudio(convertedBuffer, \"local_input_converted\");\n\n            const tempWavFile = path.join(\n                this.CONTENT_CACHE_DIR,\n                `temp_${Date.now()}.wav`\n            );\n\n            // Convert the ArrayBuffer to a Uint8Array which fs.writeFileSync can handle\n            const uint8Array = new Uint8Array(convertedBuffer);\n            fs.writeFileSync(tempWavFile, uint8Array);\n\n            elizaLogger.debug(`Temporary WAV file created: ${tempWavFile}`);\n\n            let output = await nodewhisper(tempWavFile, {\n                modelName: \"base.en\",\n                autoDownloadModelName: \"base.en\",\n                removeWavFileAfterTranscription: false,\n                withCuda: this.isCudaAvailable,\n                whisperOptions: {\n                    outputInText: true,\n                    outputInVtt: false,\n                    outputInSrt: false,\n                    outputInCsv: false,\n                    translateToEnglish: false,\n                    wordTimestamps: false,\n                    timestamps_length: 60,\n                    // splitOnWord: true,\n                },\n            });\n\n            output = output\n                .split(\"\\n\")\n                .map((line) => {\n                    if (line.trim().startsWith(\"[\")) {\n                        const endIndex = line.indexOf(\"]\");\n                        return line.substring(endIndex + 1);\n                    }\n                    return line;\n                })\n                .join(\"\\n\");\n\n            fs.unlinkSync(tempWavFile);\n\n            if (!output || output.length < 5) {\n                elizaLogger.log(\"Output is null or too short, returning null\");\n                return null;\n            }\n            return output;\n        } catch (error) {\n            elizaLogger.error(\n                \"Error in local speech-to-text conversion:\",\n                error\n            );\n            return null;\n        }\n    }\n}\n","import {\n    SpeechService,\n    TranscriptionService,\n} from \"./services/index.js\";\n\nconst speechTTS = {\n        name: \"default\",\n        description: \"Default plugin, with basic actions and evaluators\",\n        services: [\n            new SpeechService() as any,\n            new TranscriptionService() as any,\n        ],\n        actions: [],\n    }\n    \nexport default speechTTS;\n\n"],"mappings":"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","names":["elizaLogger","Service","ServiceType"]}